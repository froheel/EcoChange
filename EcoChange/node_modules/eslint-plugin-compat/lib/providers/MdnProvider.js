"use strict";

require("core-js/modules/es.array.flat");

require("core-js/modules/es.array.unscopables.flat");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isSupportedByMDN = isSupportedByMDN;
exports.getUnsupportedTargets = getUnsupportedTargets;
exports.default = void 0;

var _astMetadataInferer = _interopRequireDefault(require("ast-metadata-inferer"));

var _semver = _interopRequireDefault(require("semver"));

var _Versioning = require("../Versioning");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const mdnRecords = new Map(_astMetadataInferer.default.map(e => [e.protoChainId, e]));
/**
 * Map ids of mdn targets to their "common/friendly" name
 */

const targetIdMappings = {
  chrome: "chrome",
  firefox: "firefox",
  opera: "opera",
  safari: "safari",
  safari_ios: "ios_saf",
  ie: "ie",
  edge_mobile: "ie_mob",
  edge: "edge",
  opera_android: "and_opera",
  chrome_android: "and_chrome",
  firefox_android: "and_firefox",
  webview_android: "and_webview",
  samsunginternet_android: "and_samsung",
  nodejs: "node"
};
const reversedTargetMappings = (0, _Versioning.reverseTargetMappings)(targetIdMappings);
/**
 * Take a target's id and return it's full name by using `targetNameMappings`
 * ex. {target: and_ff, version: 40} => 'Android FireFox 40'
 */

function formatTargetNames(target) {
  return `${_Versioning.STANDARD_TARGET_NAME_MAPPING[target.target]} ${target.version}`;
}
/**
 * Convert '9' => '9.0.0'
 */


function customCoerce(version) {
  return version.length === 1 ? [version, 0, 0].join(".") : version;
}
/*
 * Return if MDN supports the API or not
 */


function isSupportedByMDN(node, {
  version,
  target: mdnTarget
}) {
  const target = reversedTargetMappings[mdnTarget]; // If no record could be found, return true. Rules might not
  // be found because they could belong to another provider

  if (!mdnRecords.has(node.protoChainId)) return true;
  const record = mdnRecords.get(node.protoChainId);
  if (!record || !record.compat.support) return true;
  const compatRecord = record.compat.support[target];
  if (!compatRecord) return true;
  if (!Array.isArray(compatRecord) && !("version_added" in compatRecord)) return true;
  const {
    version_added: versionAdded
  } = Array.isArray(compatRecord) ? compatRecord.find(e => "version_added" in e) : compatRecord; // If a version is true then it is supported but version is unsure

  if (typeof versionAdded === "boolean") return versionAdded;
  if (versionAdded === null) return true; // Special case for Safari TP: TP is always gte than any other releases

  if (target === "safari") {
    if (version === "TP") return true;
    if (versionAdded === "TP") return false;
  } // A browser supports an API if its version is greater than or equal
  // to the first version of the browser that API was added in


  const semverCurrent = _semver.default.coerce(customCoerce(version));

  const semverAdded = _semver.default.coerce(customCoerce(versionAdded)); // semver.coerce() might be null for non-semvers (other than Safari TP)
  // Just warn and treat features as supported here for now to avoid lint from
  // crashing


  if (!semverCurrent) {
    // eslint-disable-next-line no-console
    console.warn(`eslint-plugin-compat: A non-semver target "${target} ${version}" matched for the feature ${node.protoChainId}, skipping. You're welcome to submit this log to https://github.com/amilajack/eslint-plugin-compat/issues for analysis.`);
    return true;
  }

  if (!versionAdded) {
    // eslint-disable-next-line no-console
    console.warn(`eslint-plugin-compat: The feature ${node.protoChainId} is supported since a non-semver target "${target} ${versionAdded}", skipping. You're welcome to submit this log to https://github.com/amilajack/eslint-plugin-compat/issues for analysis.`);
    return true;
  }

  return _semver.default.gte(semverCurrent, semverAdded);
}
/**
 * Return an array of all unsupported targets
 */


function getUnsupportedTargets(node, targets) {
  return targets.filter(target => !isSupportedByMDN(node, target)).map(formatTargetNames);
}

function getMetadataName(metadata) {
  switch (metadata.protoChain.length) {
    case 1:
      {
        return metadata.protoChain[0];
      }

    default:
      return `${metadata.protoChain.join(".")}()`;
  }
}

const MdnProvider = _astMetadataInferer.default // Create entries for each ast node type
.map(metadata => metadata.astNodeTypes.map(astNodeType => ({ ...metadata,
  name: getMetadataName(metadata),
  id: metadata.protoChainId,
  protoChainId: metadata.protoChainId,
  astNodeType,
  object: metadata.protoChain[0],
  // @TODO Handle cases where 'prototype' is in protoChain
  property: metadata.protoChain[1]
}))) // Flatten the array of arrays
.flat() // Add rule and target support logic for each entry
.map(rule => ({ ...rule,
  getUnsupportedTargets
}));

var _default = MdnProvider;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9wcm92aWRlcnMvTWRuUHJvdmlkZXIuanMiXSwibmFtZXMiOlsibWRuUmVjb3JkcyIsIk1hcCIsIkFzdE1ldGFkYXRhIiwibWFwIiwiZSIsInByb3RvQ2hhaW5JZCIsInRhcmdldElkTWFwcGluZ3MiLCJjaHJvbWUiLCJmaXJlZm94Iiwib3BlcmEiLCJzYWZhcmkiLCJzYWZhcmlfaW9zIiwiaWUiLCJlZGdlX21vYmlsZSIsImVkZ2UiLCJvcGVyYV9hbmRyb2lkIiwiY2hyb21lX2FuZHJvaWQiLCJmaXJlZm94X2FuZHJvaWQiLCJ3ZWJ2aWV3X2FuZHJvaWQiLCJzYW1zdW5naW50ZXJuZXRfYW5kcm9pZCIsIm5vZGVqcyIsInJldmVyc2VkVGFyZ2V0TWFwcGluZ3MiLCJmb3JtYXRUYXJnZXROYW1lcyIsInRhcmdldCIsIlNUQU5EQVJEX1RBUkdFVF9OQU1FX01BUFBJTkciLCJ2ZXJzaW9uIiwiY3VzdG9tQ29lcmNlIiwibGVuZ3RoIiwiam9pbiIsImlzU3VwcG9ydGVkQnlNRE4iLCJub2RlIiwibWRuVGFyZ2V0IiwiaGFzIiwicmVjb3JkIiwiZ2V0IiwiY29tcGF0Iiwic3VwcG9ydCIsImNvbXBhdFJlY29yZCIsIkFycmF5IiwiaXNBcnJheSIsInZlcnNpb25fYWRkZWQiLCJ2ZXJzaW9uQWRkZWQiLCJmaW5kIiwic2VtdmVyQ3VycmVudCIsInNlbXZlciIsImNvZXJjZSIsInNlbXZlckFkZGVkIiwiY29uc29sZSIsIndhcm4iLCJndGUiLCJnZXRVbnN1cHBvcnRlZFRhcmdldHMiLCJ0YXJnZXRzIiwiZmlsdGVyIiwiZ2V0TWV0YWRhdGFOYW1lIiwibWV0YWRhdGEiLCJwcm90b0NoYWluIiwiTWRuUHJvdmlkZXIiLCJhc3ROb2RlVHlwZXMiLCJhc3ROb2RlVHlwZSIsIm5hbWUiLCJpZCIsIm9iamVjdCIsInByb3BlcnR5IiwiZmxhdCIsInJ1bGUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7OztBQXlCQSxN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QyxVQUFULENBQW9CLENBQXBCLENBQVA7QUFDRDs7QUFDRDtBQUNFLGFBQVEsR0FBRUQsUUFBUSxDQUFDQyxVQUFULENBQW9CM0IsSUFBcEIsQ0FBeUIsR0FBekIsQ0FBOEIsSUFBeEM7QUFMSjtBQU9EOztBQUVELE1BQU00QixXQUF3QixHQUFHdEQsNEJBQy9CO0FBRCtCLENBRTlCQyxHQUY4QixDQUUxQm1ELFFBQVEsSUFDWEEsUUFBUSxDQUFDRyxZQUFULENBQXNCdEQsR0FBdEIsQ0FBMEJ1RCxXQUFXLEtBQUssRUFDeEMsR0FBR0osUUFEcUM7QUFFeENLLEVBQUFBLElBQUksRUFBRU4sZUFBZSxDQUFDQyxRQUFELENBRm1CO0FBR3hDTSxFQUFBQSxFQUFFLEVBQUVOLFFBQVEsQ0FBQ2pELFlBSDJCO0FBSXhDQSxFQUFBQSxZQUFZLEVBQUVpRCxRQUFRLENBQUNqRCxZQUppQjtBQUt4Q3FELEVBQUFBLFdBTHdDO0FBTXhDRyxFQUFBQSxNQUFNLEVBQUVQLFFBQVEsQ0FBQ0MsVUFBVCxDQUFvQixDQUFwQixDQU5nQztBQU94QztBQUNBTyxFQUFBQSxRQUFRLEVBQUVSLFFBQVEsQ0FBQ0MsVUFBVCxDQUFvQixDQUFwQjtBQVI4QixDQUFMLENBQXJDLENBSDZCLEVBYy9CO0FBZCtCLENBZTlCUSxJQWY4QixHQWdCL0I7QUFoQitCLENBaUI5QjVELEdBakI4QixDQWlCMUI2RCxJQUFJLEtBQUssRUFDWixHQUFHQSxJQURTO0FBRVpkLEVBQUFBO0FBRlksQ0FBTCxDQWpCc0IsQ0FBakM7O2VBc0JlTSxXIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEFzdE1ldGFkYXRhIGZyb20gXCJhc3QtbWV0YWRhdGEtaW5mZXJlclwiO1xuaW1wb3J0IHNlbXZlciBmcm9tIFwic2VtdmVyXCI7XG5pbXBvcnQge1xuICBTVEFOREFSRF9UQVJHRVRfTkFNRV9NQVBQSU5HLFxuICByZXZlcnNlVGFyZ2V0TWFwcGluZ3Ncbn0gZnJvbSBcIi4uL1ZlcnNpb25pbmdcIjtcbmltcG9ydCB0eXBlIHsgTm9kZSwgVGFyZ2V0cywgVGFyZ2V0IH0gZnJvbSBcIi4uL0xpbnRUeXBlc1wiO1xuXG4vLyBAVE9ETyBJbXBvcnQgdGhpcyB0eXBlIGZyb20gYXN0LW1ldGFkYXRhLWluZmVyZXIgYWZ0ZXIgbWlncmF0aW5nIHRoaXMgcHJvamVjdCB0byBUeXBlU2NyaXB0XG50eXBlIEFzdE1ldGFkYXRhUmVjb3JkVHlwZSA9IHtcbiAgYXBpVHlwZTogXCJqcy1hcGlcIiB8IFwiY3NzLWFwaVwiLFxuICB0eXBlOiBcImpzLWFwaVwiIHwgXCJjc3MtYXBpXCIsXG4gIHByb3RvQ2hhaW46IEFycmF5PHN0cmluZz4sXG4gIHByb3RvQ2hhaW5JZDogc3RyaW5nLFxuICBhc3ROb2RlVHlwZXM6IEFycmF5PHN0cmluZz4sXG4gIGlzU3RhdGljOiBib29sZWFuLFxuICBjb21wYXQ6IHtcbiAgICBzdXBwb3J0OiB7XG4gICAgICBbYnJvd3Nlck5hbWU6IHN0cmluZ106IHtcbiAgICAgICAgLy8gSWYgYSB2ZXJzaW9uIGlzIHRydWUgdGhlbiBpdCBpcyBzdXBwb3J0ZWQgYnV0IHZlcnNpb24gaXMgdW5zdXJlXG4gICAgICAgIHZlcnNpb25fYWRkZWQ6IHN0cmluZyB8IGJvb2xlYW5cbiAgICAgIH1cbiAgICB9LFxuICAgIFt4OiBzdHJpbmddOiBhbnlcbiAgfVxufTtcblxuY29uc3QgbWRuUmVjb3JkczogTWFwPHN0cmluZywgQXN0TWV0YWRhdGFSZWNvcmRUeXBlPiA9IG5ldyBNYXAoXG4gIEFzdE1ldGFkYXRhLm1hcChlID0+IFtlLnByb3RvQ2hhaW5JZCwgZV0pXG4pO1xuXG4vKipcbiAqIE1hcCBpZHMgb2YgbWRuIHRhcmdldHMgdG8gdGhlaXIgXCJjb21tb24vZnJpZW5kbHlcIiBuYW1lXG4gKi9cbmNvbnN0IHRhcmdldElkTWFwcGluZ3MgPSB7XG4gIGNocm9tZTogXCJjaHJvbWVcIixcbiAgZmlyZWZveDogXCJmaXJlZm94XCIsXG4gIG9wZXJhOiBcIm9wZXJhXCIsXG4gIHNhZmFyaTogXCJzYWZhcmlcIixcbiAgc2FmYXJpX2lvczogXCJpb3Nfc2FmXCIsXG4gIGllOiBcImllXCIsXG4gIGVkZ2VfbW9iaWxlOiBcImllX21vYlwiLFxuICBlZGdlOiBcImVkZ2VcIixcbiAgb3BlcmFfYW5kcm9pZDogXCJhbmRfb3BlcmFcIixcbiAgY2hyb21lX2FuZHJvaWQ6IFwiYW5kX2Nocm9tZVwiLFxuICBmaXJlZm94X2FuZHJvaWQ6IFwiYW5kX2ZpcmVmb3hcIixcbiAgd2Vidmlld19hbmRyb2lkOiBcImFuZF93ZWJ2aWV3XCIsXG4gIHNhbXN1bmdpbnRlcm5ldF9hbmRyb2lkOiBcImFuZF9zYW1zdW5nXCIsXG4gIG5vZGVqczogXCJub2RlXCJcbn07XG5cbmNvbnN0IHJldmVyc2VkVGFyZ2V0TWFwcGluZ3MgPSByZXZlcnNlVGFyZ2V0TWFwcGluZ3ModGFyZ2V0SWRNYXBwaW5ncyk7XG5cbi8qKlxuICogVGFrZSBhIHRhcmdldCdzIGlkIGFuZCByZXR1cm4gaXQncyBmdWxsIG5hbWUgYnkgdXNpbmcgYHRhcmdldE5hbWVNYXBwaW5nc2BcbiAqIGV4LiB7dGFyZ2V0OiBhbmRfZmYsIHZlcnNpb246IDQwfSA9PiAnQW5kcm9pZCBGaXJlRm94IDQwJ1xuICovXG5mdW5jdGlvbiBmb3JtYXRUYXJnZXROYW1lcyh0YXJnZXQ6IFRhcmdldCk6IHN0cmluZyB7XG4gIHJldHVybiBgJHtTVEFOREFSRF9UQVJHRVRfTkFNRV9NQVBQSU5HW3RhcmdldC50YXJnZXRdfSAke3RhcmdldC52ZXJzaW9ufWA7XG59XG5cbi8qKlxuICogQ29udmVydCAnOScgPT4gJzkuMC4wJ1xuICovXG5mdW5jdGlvbiBjdXN0b21Db2VyY2UodmVyc2lvbjogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIHZlcnNpb24ubGVuZ3RoID09PSAxID8gW3ZlcnNpb24sIDAsIDBdLmpvaW4oXCIuXCIpIDogdmVyc2lvbjtcbn1cblxuLypcbiAqIFJldHVybiBpZiBNRE4gc3VwcG9ydHMgdGhlIEFQSSBvciBub3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzU3VwcG9ydGVkQnlNRE4oXG4gIG5vZGU6IE5vZGUsXG4gIHsgdmVyc2lvbiwgdGFyZ2V0OiBtZG5UYXJnZXQgfTogVGFyZ2V0XG4pOiBib29sZWFuIHtcbiAgY29uc3QgdGFyZ2V0ID0gcmV2ZXJzZWRUYXJnZXRNYXBwaW5nc1ttZG5UYXJnZXRdO1xuICAvLyBJZiBubyByZWNvcmQgY291bGQgYmUgZm91bmQsIHJldHVybiB0cnVlLiBSdWxlcyBtaWdodCBub3RcbiAgLy8gYmUgZm91bmQgYmVjYXVzZSB0aGV5IGNvdWxkIGJlbG9uZyB0byBhbm90aGVyIHByb3ZpZGVyXG4gIGlmICghbWRuUmVjb3Jkcy5oYXMobm9kZS5wcm90b0NoYWluSWQpKSByZXR1cm4gdHJ1ZTtcbiAgY29uc3QgcmVjb3JkID0gbWRuUmVjb3Jkcy5nZXQobm9kZS5wcm90b0NoYWluSWQpO1xuICBpZiAoIXJlY29yZCB8fCAhcmVjb3JkLmNvbXBhdC5zdXBwb3J0KSByZXR1cm4gdHJ1ZTtcbiAgY29uc3QgY29tcGF0UmVjb3JkID0gcmVjb3JkLmNvbXBhdC5zdXBwb3J0W3RhcmdldF07XG4gIGlmICghY29tcGF0UmVjb3JkKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGNvbXBhdFJlY29yZCkgJiYgIShcInZlcnNpb25fYWRkZWRcIiBpbiBjb21wYXRSZWNvcmQpKVxuICAgIHJldHVybiB0cnVlO1xuICBjb25zdCB7IHZlcnNpb25fYWRkZWQ6IHZlcnNpb25BZGRlZCB9ID0gQXJyYXkuaXNBcnJheShjb21wYXRSZWNvcmQpXG4gICAgPyBjb21wYXRSZWNvcmQuZmluZChlID0+IFwidmVyc2lvbl9hZGRlZFwiIGluIGUpXG4gICAgOiBjb21wYXRSZWNvcmQ7XG5cbiAgLy8gSWYgYSB2ZXJzaW9uIGlzIHRydWUgdGhlbiBpdCBpcyBzdXBwb3J0ZWQgYnV0IHZlcnNpb24gaXMgdW5zdXJlXG4gIGlmICh0eXBlb2YgdmVyc2lvbkFkZGVkID09PSBcImJvb2xlYW5cIikgcmV0dXJuIHZlcnNpb25BZGRlZDtcbiAgaWYgKHZlcnNpb25BZGRlZCA9PT0gbnVsbCkgcmV0dXJuIHRydWU7XG5cbiAgLy8gU3BlY2lhbCBjYXNlIGZvciBTYWZhcmkgVFA6IFRQIGlzIGFsd2F5cyBndGUgdGhhbiBhbnkgb3RoZXIgcmVsZWFzZXNcbiAgaWYgKHRhcmdldCA9PT0gXCJzYWZhcmlcIikge1xuICAgIGlmICh2ZXJzaW9uID09PSBcIlRQXCIpIHJldHVybiB0cnVlO1xuICAgIGlmICh2ZXJzaW9uQWRkZWQgPT09IFwiVFBcIikgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIEEgYnJvd3NlciBzdXBwb3J0cyBhbiBBUEkgaWYgaXRzIHZlcnNpb24gaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsXG4gIC8vIHRvIHRoZSBmaXJzdCB2ZXJzaW9uIG9mIHRoZSBicm93c2VyIHRoYXQgQVBJIHdhcyBhZGRlZCBpblxuICBjb25zdCBzZW12ZXJDdXJyZW50ID0gc2VtdmVyLmNvZXJjZShjdXN0b21Db2VyY2UodmVyc2lvbikpO1xuICBjb25zdCBzZW12ZXJBZGRlZCA9IHNlbXZlci5jb2VyY2UoY3VzdG9tQ29lcmNlKHZlcnNpb25BZGRlZCkpO1xuXG4gIC8vIHNlbXZlci5jb2VyY2UoKSBtaWdodCBiZSBudWxsIGZvciBub24tc2VtdmVycyAob3RoZXIgdGhhbiBTYWZhcmkgVFApXG4gIC8vIEp1c3Qgd2FybiBhbmQgdHJlYXQgZmVhdHVyZXMgYXMgc3VwcG9ydGVkIGhlcmUgZm9yIG5vdyB0byBhdm9pZCBsaW50IGZyb21cbiAgLy8gY3Jhc2hpbmdcbiAgaWYgKCFzZW12ZXJDdXJyZW50KSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICBgZXNsaW50LXBsdWdpbi1jb21wYXQ6IEEgbm9uLXNlbXZlciB0YXJnZXQgXCIke3RhcmdldH0gJHt2ZXJzaW9ufVwiIG1hdGNoZWQgZm9yIHRoZSBmZWF0dXJlICR7bm9kZS5wcm90b0NoYWluSWR9LCBza2lwcGluZy4gWW91J3JlIHdlbGNvbWUgdG8gc3VibWl0IHRoaXMgbG9nIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9hbWlsYWphY2svZXNsaW50LXBsdWdpbi1jb21wYXQvaXNzdWVzIGZvciBhbmFseXNpcy5gXG4gICAgKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoIXZlcnNpb25BZGRlZCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgY29uc29sZS53YXJuKFxuICAgICAgYGVzbGludC1wbHVnaW4tY29tcGF0OiBUaGUgZmVhdHVyZSAke25vZGUucHJvdG9DaGFpbklkfSBpcyBzdXBwb3J0ZWQgc2luY2UgYSBub24tc2VtdmVyIHRhcmdldCBcIiR7dGFyZ2V0fSAke3ZlcnNpb25BZGRlZH1cIiwgc2tpcHBpbmcuIFlvdSdyZSB3ZWxjb21lIHRvIHN1Ym1pdCB0aGlzIGxvZyB0byBodHRwczovL2dpdGh1Yi5jb20vYW1pbGFqYWNrL2VzbGludC1wbHVnaW4tY29tcGF0L2lzc3VlcyBmb3IgYW5hbHlzaXMuYFxuICAgICk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIHNlbXZlci5ndGUoc2VtdmVyQ3VycmVudCwgc2VtdmVyQWRkZWQpO1xufVxuXG4vKipcbiAqIFJldHVybiBhbiBhcnJheSBvZiBhbGwgdW5zdXBwb3J0ZWQgdGFyZ2V0c1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VW5zdXBwb3J0ZWRUYXJnZXRzKFxuICBub2RlOiBOb2RlLFxuICB0YXJnZXRzOiBUYXJnZXRzXG4pOiBBcnJheTxzdHJpbmc+IHtcbiAgcmV0dXJuIHRhcmdldHNcbiAgICAuZmlsdGVyKHRhcmdldCA9PiAhaXNTdXBwb3J0ZWRCeU1ETihub2RlLCB0YXJnZXQpKVxuICAgIC5tYXAoZm9ybWF0VGFyZ2V0TmFtZXMpO1xufVxuXG5mdW5jdGlvbiBnZXRNZXRhZGF0YU5hbWUobWV0YWRhdGE6IE5vZGUpIHtcbiAgc3dpdGNoIChtZXRhZGF0YS5wcm90b0NoYWluLmxlbmd0aCkge1xuICAgIGNhc2UgMToge1xuICAgICAgcmV0dXJuIG1ldGFkYXRhLnByb3RvQ2hhaW5bMF07XG4gICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gYCR7bWV0YWRhdGEucHJvdG9DaGFpbi5qb2luKFwiLlwiKX0oKWA7XG4gIH1cbn1cblxuY29uc3QgTWRuUHJvdmlkZXI6IEFycmF5PE5vZGU+ID0gQXN0TWV0YWRhdGFcbiAgLy8gQ3JlYXRlIGVudHJpZXMgZm9yIGVhY2ggYXN0IG5vZGUgdHlwZVxuICAubWFwKG1ldGFkYXRhID0+XG4gICAgbWV0YWRhdGEuYXN0Tm9kZVR5cGVzLm1hcChhc3ROb2RlVHlwZSA9PiAoe1xuICAgICAgLi4ubWV0YWRhdGEsXG4gICAgICBuYW1lOiBnZXRNZXRhZGF0YU5hbWUobWV0YWRhdGEpLFxuICAgICAgaWQ6IG1ldGFkYXRhLnByb3RvQ2hhaW5JZCxcbiAgICAgIHByb3RvQ2hhaW5JZDogbWV0YWRhdGEucHJvdG9DaGFpbklkLFxuICAgICAgYXN0Tm9kZVR5cGUsXG4gICAgICBvYmplY3Q6IG1ldGFkYXRhLnByb3RvQ2hhaW5bMF0sXG4gICAgICAvLyBAVE9ETyBIYW5kbGUgY2FzZXMgd2hlcmUgJ3Byb3RvdHlwZScgaXMgaW4gcHJvdG9DaGFpblxuICAgICAgcHJvcGVydHk6IG1ldGFkYXRhLnByb3RvQ2hhaW5bMV1cbiAgICB9KSlcbiAgKVxuICAvLyBGbGF0dGVuIHRoZSBhcnJheSBvZiBhcnJheXNcbiAgLmZsYXQoKVxuICAvLyBBZGQgcnVsZSBhbmQgdGFyZ2V0IHN1cHBvcnQgbG9naWMgZm9yIGVhY2ggZW50cnlcbiAgLm1hcChydWxlID0+ICh7XG4gICAgLi4ucnVsZSxcbiAgICBnZXRVbnN1cHBvcnRlZFRhcmdldHNcbiAgfSkpO1xuXG5leHBvcnQgZGVmYXVsdCBNZG5Qcm92aWRlcjtcbiJdfQ==