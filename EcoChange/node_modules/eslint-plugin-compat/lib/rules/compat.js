"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = _interopRequireDefault(require("lodash.memoize"));

var _Lint = require("../Lint");

var _Versioning = _interopRequireWildcard(require("../Versioning"));

var _providers = require("../providers");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getName(node) {
  switch (node.type) {
    case "NewExpression":
      {
        return node.callee.name;
      }

    case "MemberExpression":
      {
        return node.object.name;
      }

    case "CallExpression":
      {
        return node.callee.name;
      }

    default:
      throw new Error("not found");
  }
}

function generateErrorName(rule) {
  if (rule.name) return rule.name;
  if (rule.property) return `${rule.object}.${rule.property}()`;
  return rule.object;
}

const getPolyfillSet = (0, _lodash.default)(polyfillArrayJSON => new Set(JSON.parse(polyfillArrayJSON)));

function isPolyfilled(context, rule) {
  if (!context.settings.polyfills) return false;
  const polyfills = getPolyfillSet(JSON.stringify(context.settings.polyfills));
  return (// v2 allowed users to select polyfills based off their caniuseId. This is
    // no longer supported. Keeping this here to avoid breaking changes.
    polyfills.has(rule.id) || // Check if polyfill is provided (ex. `Promise.all`)
    polyfills.has(rule.protoChainId) || // Check if entire API is polyfilled (ex. `Promise`)
    polyfills.has(rule.protoChain[0])
  );
}

const getRulesForTargets = (0, _lodash.default)(targetsJSON => {
  const result = {
    CallExpression: [],
    NewExpression: [],
    MemberExpression: []
  };
  const targets = JSON.parse(targetsJSON);

  _providers.nodes.forEach(node => {
    if (node.getUnsupportedTargets(node, targets).length === 0) return;
    result[node.astNodeType].push(node);
  });

  return result;
});
var _default = {
  meta: {
    docs: {
      description: "Ensure cross-browser API compatibility",
      category: "Compatibility",
      url: "https://github.com/amilajack/eslint-plugin-compat/blob/master/docs/rules/compat.md",
      recommended: true
    },
    type: "problem",
    schema: [{
      type: "string"
    }]
  },

  create(context) {
    // Determine lowest targets from browserslist config, which reads user's
    // package.json config section. Use config from eslintrc for testing purposes
    const browserslistConfig = context.settings.browsers || context.settings.targets || context.options[0];
    const browserslistTargets = (0, _Versioning.Versioning)((0, _Versioning.default)(context.getFilename(), browserslistConfig)); // Stringify to support memoization; browserslistConfig is always an array of new objects.

    const targetedRules = getRulesForTargets(JSON.stringify(browserslistTargets));
    const errors = [];

    function handleFailingRule(node, eslintNode) {
      if (isPolyfilled(context, node)) return;
      errors.push({
        node: eslintNode,
        message: [generateErrorName(node), "is not supported in", node.getUnsupportedTargets(node, browserslistTargets).join(", ")].join(" ")
      });
    }

    const identifiers = new Set();
    return {
      CallExpression: _Lint.lintCallExpression.bind(null, handleFailingRule, targetedRules.CallExpression),
      NewExpression: _Lint.lintNewExpression.bind(null, handleFailingRule, targetedRules.NewExpression),
      MemberExpression: _Lint.lintMemberExpression.bind(null, handleFailingRule, targetedRules.MemberExpression),

      // Keep track of all the defined variables. Do not report errors for nodes that are not defined
      Identifier(node) {
        if (node.parent) {
          const {
            type
          } = node.parent;

          if ( // ex. const { Set } = require('immutable');
          type === "Property" || // ex. function Set() {}
          type === "FunctionDeclaration" || // ex. const Set = () => {}
          type === "VariableDeclarator" || // ex. class Set {}
          type === "ClassDeclaration" || // ex. import Set from 'set';
          type === "ImportDefaultSpecifier" || // ex. import {Set} from 'set';
          type === "ImportSpecifier" || // ex. import {Set} from 'set';
          type === "ImportDeclaration") {
            identifiers.add(node.name);
          }
        }
      },

      "Program:exit": () => {
        // Get a map of all the variables defined in the root scope (not the global scope)
        // const variablesMap = context.getScope().childScopes.map(e => e.set)[0];
        errors.filter(error => !identifiers.has(getName(error.node))).forEach(node => context.report(node));
      }
    };
  }

};
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9ydWxlcy9jb21wYXQuanMiXSwibmFtZXMiOlsiZ2V0TmFtZSIsIm5vZGUiLCJ0eXBlIiwiY2FsbGVlIiwibmFtZSIsIm9iamVjdCIsIkVycm9yIiwiZ2VuZXJhdGVFcnJvck5hbWUiLCJydWxlIiwicHJvcGVydHkiLCJnZXRQb2x5ZmlsbFNldCIsInBvbHlmaWxsQXJyYXlKU09OIiwiU2V0IiwiSlNPTiIsInBhcnNlIiwiaXNQb2x5ZmlsbGVkIiwiY29udGV4dCIsInNldHRpbmdzIiwicG9seWZpbGxzIiwic3RyaW5naWZ5IiwiaGFzIiwiaWQiLCJwcm90b0NoYWluSWQiLCJwcm90b0NoYWluIiwiZ2V0UnVsZXNGb3JUYXJnZXRzIiwidGFyZ2V0c0pTT04iLCJyZXN1bHQiLCJDYWxsRXhwcmVzc2lvbiIsIk5ld0V4cHJlc3Npb24iLCJNZW1iZXJFeHByZXNzaW9uIiwidGFyZ2V0cyIsIm5vZGVzIiwiZm9yRWFjaCIsImdldFVuc3VwcG9ydGVkVGFyZ2V0cyIsImxlbmd0aCIsImFzdE5vZGVUeXBlIiwicHVzaCIsIm1ldGEiLCJkb2NzIiwiZGVzY3JpcHRpb24iLCJjYXRlZ29yeSIsInVybCIsInJlY29tbWVuZGVkIiwic2NoZW1hIiwiY3JlYXRlIiwiYnJvd3NlcnNsaXN0Q29uZmlnIiwiYnJvd3NlcnMiLCJvcHRpb25zIiwiYnJvd3NlcnNsaXN0VGFyZ2V0cyIsImdldEZpbGVuYW1lIiwidGFyZ2V0ZWRSdWxlcyIsImVycm9ycyIsImhhbmRsZUZhaWxpbmdSdWxlIiwiZXNsaW50Tm9kZSIsIm1lc3NhZ2UiLCJqb2luIiwiaWRlbnRpZmllcnMiLCJsaW50Q2FsbEV4cHJlc3Npb24iLCJiaW5kIiwibGludE5ld0V4cHJlc3Npb24iLCJsaW50TWVtYmVyRXhwcmVzc2lvbiIsIklkZW50aWZpZXIiLCJwYXJlbnQiLCJhZGQiLCJmaWx0ZXIiLCJlcnJvciIsInJlcG9ydCJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUNBOztBQUNBOztBQUtBOztB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b3J0IHtcbiAgbGludENhbGxFeHByZXNzaW9uLFxuICBsaW50TWVtYmVyRXhwcmVzc2lvbixcbiAgbGludE5ld0V4cHJlc3Npb25cbn0gZnJvbSBcIi4uL0xpbnRcIjtcbmltcG9ydCBkZXRlcm1pbmVUYXJnZXRzRnJvbUNvbmZpZywgeyBWZXJzaW9uaW5nIH0gZnJvbSBcIi4uL1ZlcnNpb25pbmdcIjtcbmltcG9ydCB0eXBlIHsgRVNMaW50Tm9kZSwgTm9kZSwgQnJvd3Nlckxpc3RDb25maWcgfSBmcm9tIFwiLi4vTGludFR5cGVzXCI7XG5pbXBvcnQgeyBub2RlcyB9IGZyb20gXCIuLi9wcm92aWRlcnNcIjtcblxudHlwZSBFU0xpbnQgPSB7XG4gIFthc3ROb2RlVHlwZU5hbWU6IHN0cmluZ106IChub2RlOiBFU0xpbnROb2RlKSA9PiB2b2lkXG59O1xuXG50eXBlIENvbnRleHQgPSB7XG4gIG5vZGU6IEVTTGludE5vZGUsXG4gIG9wdGlvbnM6IEFycmF5PHN0cmluZz4sXG4gIHNldHRpbmdzOiB7XG4gICAgYnJvd3NlcnM6IEFycmF5PHN0cmluZz4sXG4gICAgcG9seWZpbGxzOiBBcnJheTxzdHJpbmc+XG4gIH0sXG4gIGdldEZpbGVuYW1lOiAoKSA9PiBzdHJpbmcsXG4gIHJlcG9ydDogKCkgPT4gdm9pZFxufTtcblxuZnVuY3Rpb24gZ2V0TmFtZShub2RlOiBFU0xpbnROb2RlKTogc3RyaW5nIHtcbiAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICBjYXNlIFwiTmV3RXhwcmVzc2lvblwiOiB7XG4gICAgICByZXR1cm4gbm9kZS5jYWxsZWUubmFtZTtcbiAgICB9XG4gICAgY2FzZSBcIk1lbWJlckV4cHJlc3Npb25cIjoge1xuICAgICAgcmV0dXJuIG5vZGUub2JqZWN0Lm5hbWU7XG4gICAgfVxuICAgIGNhc2UgXCJDYWxsRXhwcmVzc2lvblwiOiB7XG4gICAgICByZXR1cm4gbm9kZS5jYWxsZWUubmFtZTtcbiAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vdCBmb3VuZFwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZUVycm9yTmFtZShydWxlOiBOb2RlKTogc3RyaW5nIHtcbiAgaWYgKHJ1bGUubmFtZSkgcmV0dXJuIHJ1bGUubmFtZTtcbiAgaWYgKHJ1bGUucHJvcGVydHkpIHJldHVybiBgJHtydWxlLm9iamVjdH0uJHtydWxlLnByb3BlcnR5fSgpYDtcbiAgcmV0dXJuIHJ1bGUub2JqZWN0O1xufVxuXG5jb25zdCBnZXRQb2x5ZmlsbFNldCA9IG1lbW9pemUoXG4gIChwb2x5ZmlsbEFycmF5SlNPTjogc3RyaW5nKTogU2V0PFN0cmluZz4gPT5cbiAgICBuZXcgU2V0KEpTT04ucGFyc2UocG9seWZpbGxBcnJheUpTT04pKVxuKTtcblxuZnVuY3Rpb24gaXNQb2x5ZmlsbGVkKGNvbnRleHQ6IENvbnRleHQsIHJ1bGU6IE5vZGUpOiBib29sZWFuIHtcbiAgaWYgKCFjb250ZXh0LnNldHRpbmdzLnBvbHlmaWxscykgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBwb2x5ZmlsbHMgPSBnZXRQb2x5ZmlsbFNldChKU09OLnN0cmluZ2lmeShjb250ZXh0LnNldHRpbmdzLnBvbHlmaWxscykpO1xuICByZXR1cm4gKFxuICAgIC8vIHYyIGFsbG93ZWQgdXNlcnMgdG8gc2VsZWN0IHBvbHlmaWxscyBiYXNlZCBvZmYgdGhlaXIgY2FuaXVzZUlkLiBUaGlzIGlzXG4gICAgLy8gbm8gbG9uZ2VyIHN1cHBvcnRlZC4gS2VlcGluZyB0aGlzIGhlcmUgdG8gYXZvaWQgYnJlYWtpbmcgY2hhbmdlcy5cbiAgICBwb2x5ZmlsbHMuaGFzKHJ1bGUuaWQpIHx8XG4gICAgLy8gQ2hlY2sgaWYgcG9seWZpbGwgaXMgcHJvdmlkZWQgKGV4LiBgUHJvbWlzZS5hbGxgKVxuICAgIHBvbHlmaWxscy5oYXMocnVsZS5wcm90b0NoYWluSWQpIHx8XG4gICAgLy8gQ2hlY2sgaWYgZW50aXJlIEFQSSBpcyBwb2x5ZmlsbGVkIChleC4gYFByb21pc2VgKVxuICAgIHBvbHlmaWxscy5oYXMocnVsZS5wcm90b0NoYWluWzBdKVxuICApO1xufVxuXG5jb25zdCBnZXRSdWxlc0ZvclRhcmdldHMgPSBtZW1vaXplKCh0YXJnZXRzSlNPTjogc3RyaW5nKTogT2JqZWN0ID0+IHtcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIENhbGxFeHByZXNzaW9uOiBbXSxcbiAgICBOZXdFeHByZXNzaW9uOiBbXSxcbiAgICBNZW1iZXJFeHByZXNzaW9uOiBbXVxuICB9O1xuICBjb25zdCB0YXJnZXRzID0gSlNPTi5wYXJzZSh0YXJnZXRzSlNPTik7XG4gIG5vZGVzLmZvckVhY2gobm9kZSA9PiB7XG4gICAgaWYgKG5vZGUuZ2V0VW5zdXBwb3J0ZWRUYXJnZXRzKG5vZGUsIHRhcmdldHMpLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgIHJlc3VsdFtub2RlLmFzdE5vZGVUeXBlXS5wdXNoKG5vZGUpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG1ldGE6IHtcbiAgICBkb2NzOiB7XG4gICAgICBkZXNjcmlwdGlvbjogXCJFbnN1cmUgY3Jvc3MtYnJvd3NlciBBUEkgY29tcGF0aWJpbGl0eVwiLFxuICAgICAgY2F0ZWdvcnk6IFwiQ29tcGF0aWJpbGl0eVwiLFxuICAgICAgdXJsOlxuICAgICAgICBcImh0dHBzOi8vZ2l0aHViLmNvbS9hbWlsYWphY2svZXNsaW50LXBsdWdpbi1jb21wYXQvYmxvYi9tYXN0ZXIvZG9jcy9ydWxlcy9jb21wYXQubWRcIixcbiAgICAgIHJlY29tbWVuZGVkOiB0cnVlXG4gICAgfSxcbiAgICB0eXBlOiBcInByb2JsZW1cIixcbiAgICBzY2hlbWE6IFt7IHR5cGU6IFwic3RyaW5nXCIgfV1cbiAgfSxcbiAgY3JlYXRlKGNvbnRleHQ6IENvbnRleHQpOiBFU0xpbnQge1xuICAgIC8vIERldGVybWluZSBsb3dlc3QgdGFyZ2V0cyBmcm9tIGJyb3dzZXJzbGlzdCBjb25maWcsIHdoaWNoIHJlYWRzIHVzZXInc1xuICAgIC8vIHBhY2thZ2UuanNvbiBjb25maWcgc2VjdGlvbi4gVXNlIGNvbmZpZyBmcm9tIGVzbGludHJjIGZvciB0ZXN0aW5nIHB1cnBvc2VzXG4gICAgY29uc3QgYnJvd3NlcnNsaXN0Q29uZmlnOiBCcm93c2VyTGlzdENvbmZpZyA9XG4gICAgICBjb250ZXh0LnNldHRpbmdzLmJyb3dzZXJzIHx8XG4gICAgICBjb250ZXh0LnNldHRpbmdzLnRhcmdldHMgfHxcbiAgICAgIGNvbnRleHQub3B0aW9uc1swXTtcblxuICAgIGNvbnN0IGJyb3dzZXJzbGlzdFRhcmdldHMgPSBWZXJzaW9uaW5nKFxuICAgICAgZGV0ZXJtaW5lVGFyZ2V0c0Zyb21Db25maWcoY29udGV4dC5nZXRGaWxlbmFtZSgpLCBicm93c2Vyc2xpc3RDb25maWcpXG4gICAgKTtcblxuICAgIC8vIFN0cmluZ2lmeSB0byBzdXBwb3J0IG1lbW9pemF0aW9uOyBicm93c2Vyc2xpc3RDb25maWcgaXMgYWx3YXlzIGFuIGFycmF5IG9mIG5ldyBvYmplY3RzLlxuICAgIGNvbnN0IHRhcmdldGVkUnVsZXMgPSBnZXRSdWxlc0ZvclRhcmdldHMoXG4gICAgICBKU09OLnN0cmluZ2lmeShicm93c2Vyc2xpc3RUYXJnZXRzKVxuICAgICk7XG5cbiAgICBjb25zdCBlcnJvcnMgPSBbXTtcblxuICAgIGZ1bmN0aW9uIGhhbmRsZUZhaWxpbmdSdWxlKG5vZGU6IE5vZGUsIGVzbGludE5vZGU6IEVTTGludE5vZGUpIHtcbiAgICAgIGlmIChpc1BvbHlmaWxsZWQoY29udGV4dCwgbm9kZSkpIHJldHVybjtcbiAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgbm9kZTogZXNsaW50Tm9kZSxcbiAgICAgICAgbWVzc2FnZTogW1xuICAgICAgICAgIGdlbmVyYXRlRXJyb3JOYW1lKG5vZGUpLFxuICAgICAgICAgIFwiaXMgbm90IHN1cHBvcnRlZCBpblwiLFxuICAgICAgICAgIG5vZGUuZ2V0VW5zdXBwb3J0ZWRUYXJnZXRzKG5vZGUsIGJyb3dzZXJzbGlzdFRhcmdldHMpLmpvaW4oXCIsIFwiKVxuICAgICAgICBdLmpvaW4oXCIgXCIpXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBpZGVudGlmaWVycyA9IG5ldyBTZXQoKTtcblxuICAgIHJldHVybiB7XG4gICAgICBDYWxsRXhwcmVzc2lvbjogbGludENhbGxFeHByZXNzaW9uLmJpbmQoXG4gICAgICAgIG51bGwsXG4gICAgICAgIGhhbmRsZUZhaWxpbmdSdWxlLFxuICAgICAgICB0YXJnZXRlZFJ1bGVzLkNhbGxFeHByZXNzaW9uXG4gICAgICApLFxuICAgICAgTmV3RXhwcmVzc2lvbjogbGludE5ld0V4cHJlc3Npb24uYmluZChcbiAgICAgICAgbnVsbCxcbiAgICAgICAgaGFuZGxlRmFpbGluZ1J1bGUsXG4gICAgICAgIHRhcmdldGVkUnVsZXMuTmV3RXhwcmVzc2lvblxuICAgICAgKSxcbiAgICAgIE1lbWJlckV4cHJlc3Npb246IGxpbnRNZW1iZXJFeHByZXNzaW9uLmJpbmQoXG4gICAgICAgIG51bGwsXG4gICAgICAgIGhhbmRsZUZhaWxpbmdSdWxlLFxuICAgICAgICB0YXJnZXRlZFJ1bGVzLk1lbWJlckV4cHJlc3Npb25cbiAgICAgICksXG4gICAgICAvLyBLZWVwIHRyYWNrIG9mIGFsbCB0aGUgZGVmaW5lZCB2YXJpYWJsZXMuIERvIG5vdCByZXBvcnQgZXJyb3JzIGZvciBub2RlcyB0aGF0IGFyZSBub3QgZGVmaW5lZFxuICAgICAgSWRlbnRpZmllcihub2RlOiBFU0xpbnROb2RlKSB7XG4gICAgICAgIGlmIChub2RlLnBhcmVudCkge1xuICAgICAgICAgIGNvbnN0IHsgdHlwZSB9ID0gbm9kZS5wYXJlbnQ7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgLy8gZXguIGNvbnN0IHsgU2V0IH0gPSByZXF1aXJlKCdpbW11dGFibGUnKTtcbiAgICAgICAgICAgIHR5cGUgPT09IFwiUHJvcGVydHlcIiB8fFxuICAgICAgICAgICAgLy8gZXguIGZ1bmN0aW9uIFNldCgpIHt9XG4gICAgICAgICAgICB0eXBlID09PSBcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIiB8fFxuICAgICAgICAgICAgLy8gZXguIGNvbnN0IFNldCA9ICgpID0+IHt9XG4gICAgICAgICAgICB0eXBlID09PSBcIlZhcmlhYmxlRGVjbGFyYXRvclwiIHx8XG4gICAgICAgICAgICAvLyBleC4gY2xhc3MgU2V0IHt9XG4gICAgICAgICAgICB0eXBlID09PSBcIkNsYXNzRGVjbGFyYXRpb25cIiB8fFxuICAgICAgICAgICAgLy8gZXguIGltcG9ydCBTZXQgZnJvbSAnc2V0JztcbiAgICAgICAgICAgIHR5cGUgPT09IFwiSW1wb3J0RGVmYXVsdFNwZWNpZmllclwiIHx8XG4gICAgICAgICAgICAvLyBleC4gaW1wb3J0IHtTZXR9IGZyb20gJ3NldCc7XG4gICAgICAgICAgICB0eXBlID09PSBcIkltcG9ydFNwZWNpZmllclwiIHx8XG4gICAgICAgICAgICAvLyBleC4gaW1wb3J0IHtTZXR9IGZyb20gJ3NldCc7XG4gICAgICAgICAgICB0eXBlID09PSBcIkltcG9ydERlY2xhcmF0aW9uXCJcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXJzLmFkZChub2RlLm5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwiUHJvZ3JhbTpleGl0XCI6ICgpID0+IHtcbiAgICAgICAgLy8gR2V0IGEgbWFwIG9mIGFsbCB0aGUgdmFyaWFibGVzIGRlZmluZWQgaW4gdGhlIHJvb3Qgc2NvcGUgKG5vdCB0aGUgZ2xvYmFsIHNjb3BlKVxuICAgICAgICAvLyBjb25zdCB2YXJpYWJsZXNNYXAgPSBjb250ZXh0LmdldFNjb3BlKCkuY2hpbGRTY29wZXMubWFwKGUgPT4gZS5zZXQpWzBdO1xuICAgICAgICBlcnJvcnNcbiAgICAgICAgICAuZmlsdGVyKGVycm9yID0+ICFpZGVudGlmaWVycy5oYXMoZ2V0TmFtZShlcnJvci5ub2RlKSkpXG4gICAgICAgICAgLmZvckVhY2gobm9kZSA9PiBjb250ZXh0LnJlcG9ydChub2RlKSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcbiJdfQ==